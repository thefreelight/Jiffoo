name: ğŸš€ Jiffoo Mall Core - Complete CI/CD to Qujing K8s

on:
  push:
    branches: [main]
    tags:
      - 'v*'
  workflow_dispatch:

# Temporarily disable concurrency to allow new workflows to run
# while old queued workflows are stuck
# concurrency:
#   group: ${{ github.workflow }}-${{ github.ref }}
#   cancel-in-progress: true

# Grant permissions for workflow
permissions:
  contents: read
  actions: read
  packages: write

env:
  REGISTRY: 192.168.0.114
  REGISTRY_URL: http://192.168.0.114
  IMAGE_NAME: jiffoo-mall-core
  # Disable BuildKit for now (buildx not installed on runners)
  # DOCKER_BUILDKIT: 1
  # BUILDKIT_PROGRESS: plain
  # Turborepo Remote Cache (è‡ªå»ºæœåŠ¡å™¨ on VM 113)
  TURBO_API: http://192.168.0.113:3001
  TURBO_TOKEN: d7eb0b51c0899a3ef0c3a5cefc9989c45371d9974acd756c44bb967b0c0819af
  TURBO_TEAM: team_jiffoo-mall-core
  # Enable detailed logging
  ACTIONS_STEP_DEBUG: true
  ACTIONS_RUNNER_DEBUG: true

jobs:
  # ğŸ¯ å‡†å¤‡ç¯å¢ƒä¿¡æ¯
  prepare:
    name: ğŸ¯ Prepare
    runs-on: jiffoo-mall-core-runners
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      namespace: ${{ steps.env.outputs.namespace }}
      version: ${{ steps.env.outputs.version }}
    steps:
      - name: ğŸ“¥ Checkout
        uses: actions/checkout@v4

      - name: ğŸ¯ Determine Environment & Version
        id: env
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "namespace=jiffoo-mall-core-prod" >> $GITHUB_OUTPUT
            echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "namespace=jiffoo-mall-core-dev" >> $GITHUB_OUTPUT
            SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
            echo "version=main-${SHORT_SHA}" >> $GITHUB_OUTPUT
          fi

          echo "ğŸ“Š Environment: $(cat $GITHUB_OUTPUT | grep environment | cut -d= -f2)"
          echo "ğŸ“¦ Namespace: $(cat $GITHUB_OUTPUT | grep namespace | cut -d= -f2)"
          echo "ğŸ·ï¸ Version: $(cat $GITHUB_OUTPUT | grep version | cut -d= -f2)"

  # ğŸ—ï¸ å¹¶è¡Œæ„å»ºå’Œæ¨é€é•œåƒï¼ˆåƒ ci.yaml ä¸€æ ·ç®€å•ï¼‰
  build-and-push:
    name: ğŸ—ï¸ Build & Push (${{ matrix.service }})
    needs: prepare
    runs-on: jiffoo-mall-core-runners
    timeout-minutes: 45
    strategy:
      fail-fast: false
      max-parallel: 9  # K8s runner should handle all 9 services in parallel
      matrix:
        service: [backend, frontend, admin, super-admin, agent-portal, white-label, distribution-plugin, docs-internal, docs-public]
    steps:
      - name: ğŸ“¥ Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: ğŸ·ï¸ Generate image tags
        id: tags
        run: |
          TAG="${{ needs.prepare.outputs.version }}"
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "ğŸ·ï¸ Image tag: ${TAG}"

      - name: ğŸ” Configure Docker Registry with Proxy
        run: |
          echo "ğŸ” Configuring Docker proxy..."
          # Configure Docker daemon proxy (if proxy is available)
          if [ -n "${{ secrets.HTTP_PROXY }}" ]; then
            sudo mkdir -p /etc/systemd/system/docker.service.d
            sudo tee /etc/systemd/system/docker.service.d/http-proxy.conf > /dev/null <<EOF
          [Service]
          Environment="HTTP_PROXY=${{ secrets.HTTP_PROXY }}"
          Environment="HTTPS_PROXY=${{ secrets.HTTPS_PROXY || secrets.HTTP_PROXY }}"
          Environment="NO_PROXY=localhost,127.0.0.1,.svc,.cluster.local"
          EOF
            sudo systemctl daemon-reload
            sudo systemctl restart docker
            echo "âœ… Docker proxy configured"
          else
            echo "âš ï¸ No proxy configured, using direct connection"
          fi

          echo "ğŸ” Adding Harbor DNS entry to /etc/hosts..."
          # Add Harbor domain to /etc/hosts to resolve DNS issue
          echo "192.168.0.114 harbor.lafdru.local" | sudo tee -a /etc/hosts
          echo "âœ… Harbor DNS entry added:"
          cat /etc/hosts | grep harbor || echo "âš ï¸ Failed to add Harbor DNS entry"

          echo "ğŸ” Logging in to Harbor Registry..."
          # Note: insecure-registry is configured in runner pod DinD container
          # Harbor is on internal network, no proxy needed
          export NO_PROXY="localhost,127.0.0.1,192.168.0.0/16,10.0.0.0/8,harbor.lafdru.local"

          # Retry logic for Docker login to Harbor
          for i in {1..3}; do
            if printf '%s\n' "${{ secrets.HARBOR_PASSWORD }}" | timeout 60 docker login ${{ env.REGISTRY }} -u "${{ secrets.HARBOR_USERNAME }}" --password-stdin; then
              echo "âœ… Harbor registry configured"
              exit 0
            fi
            echo "âš ï¸ Harbor login attempt $i failed, retrying..."
            sleep 5
          done
          echo "âŒ Harbor login failed after 3 attempts"
          exit 1

      - name: ğŸ“¦ Install pnpm
        uses: pnpm/action-setup@v4
        env:
          HTTP_PROXY: ${{ secrets.HTTP_PROXY }}
          HTTPS_PROXY: ${{ secrets.HTTPS_PROXY || secrets.HTTP_PROXY }}
          NO_PROXY: localhost,127.0.0.1

      - name: ğŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          # Disable pnpm cache to avoid timeout issues
          # cache: 'pnpm'

      - name: ğŸ”§ Configure HTTP proxy for pnpm
        run: |
          echo "ğŸ”§ Configuring HTTP proxy for pnpm..."
          if [ -n "${{ secrets.HTTP_PROXY }}" ]; then
            pnpm config set proxy "${{ secrets.HTTP_PROXY }}"
            pnpm config set https-proxy "${{ secrets.HTTPS_PROXY || secrets.HTTP_PROXY }}"
            echo "âœ… HTTP proxy configured for pnpm"
            echo "Proxy: ${{ secrets.HTTP_PROXY }}"
          else
            echo "âš ï¸ No HTTP_PROXY configured, using direct connection"
          fi
          pnpm config list

      - name: ğŸ“¦ Install dependencies
        timeout-minutes: 10
        run: |
          set -x  # Enable shell debug mode
          echo "ğŸ“¦ Installing dependencies with pnpm..."
          echo "Current directory: $(pwd)"
          echo "Node version: $(node --version)"
          echo "pnpm version: $(pnpm --version)"

          # Check lockfile status
          echo "Checking pnpm-lock.yaml..."
          ls -lh pnpm-lock.yaml

          # Try frozen lockfile first, fallback to regular install if it fails
          echo "Attempting install with frozen lockfile..."
          if ! pnpm install --frozen-lockfile --loglevel=info; then
            echo "âš ï¸ Frozen lockfile install failed, trying regular install..."
            pnpm install --loglevel=info
          fi

          echo "âœ… Dependencies installed"
          echo "Installed packages:"
          ls -la node_modules/ | head -20

          # Verify shared package is linked
          echo "Checking shared package..."
          ls -la node_modules/shared/ || echo "âš ï¸ shared package not found in node_modules"
          ls -la packages/shared/dist/ || echo "âš ï¸ shared package dist not found"

      - name: ğŸ—„ï¸ Generate Prisma Client
        if: matrix.service == 'backend'
        run: |
          echo "ğŸ—„ï¸ Generating Prisma Client..."
          cd apps/backend
          pnpm prisma generate
          echo "âœ… Prisma Client generated"
        continue-on-error: true

      - name: ğŸ“¦ Build shared package first
        run: |
          set -x  # Enable shell debug mode
          echo "ğŸ“¦ Building shared package..."

          # Check if shared package exists
          if [ ! -d "packages/shared" ]; then
            echo "âŒ ERROR: packages/shared directory not found!"
            ls -la packages/
            exit 1
          fi

          cd packages/shared
          echo "Current directory: $(pwd)"
          echo "Package.json content:"
          cat package.json

          # Check if node_modules exists
          if [ ! -d "node_modules" ]; then
            echo "âš ï¸ node_modules not found, running pnpm install..."
            pnpm install
          fi

          # Build with verbose output
          echo "Running: pnpm run build"
          pnpm run build --verbose || pnpm run build

          echo "âœ… Shared package built"
          echo "Build output:"
          if [ -d "dist" ]; then
            ls -la dist/
            echo "Dist files:"
            find dist -type f | head -20
          else
            echo "âŒ ERROR: No dist directory found after build!"
            exit 1
          fi

          # Verify the build output
          if [ ! -f "dist/index.js" ] || [ ! -f "dist/index.d.ts" ]; then
            echo "âŒ ERROR: Required build outputs missing!"
            ls -la dist/
            exit 1
          fi

          echo "âœ… Shared package build verified"
        continue-on-error: false

      - name: ğŸ—ï¸ Build with Turbo (Remote Cache Enabled)
        timeout-minutes: 20
        env:
          BACKEND_SERVICE_URL: http://jiffoo.chfastpay.com:30002
          BACKEND_SERVICE_URL_PROD: http://jiffoo.chfastpay.com:30002
          BACKEND_SERVICE_URL_DEV: http://jiffoo.chfastpay.com:30002
          NODE_ENV: production
          # Next.js public environment variables (required for build)
          NEXT_PUBLIC_API_URL: /api
          NEXT_PUBLIC_SUPER_ADMIN_URL: http://jiffoo.chfastpay.com:30002
          NEXT_PUBLIC_ADMIN_URL: http://jiffoo.chfastpay.com:30003
          NEXT_PUBLIC_FRONTEND_URL: http://jiffoo.chfastpay.com:30004
          NEXT_PUBLIC_AGENT_PORTAL_URL: http://jiffoo.chfastpay.com:30005
          NEXT_PUBLIC_WHITE_LABEL_URL: http://jiffoo.chfastpay.com:30006
          NEXT_PUBLIC_DISTRIBUTION_PLUGIN_URL: http://jiffoo.chfastpay.com:30007
          NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY: pk_test_51R5gkPB6vJBDO7CtUURHcodqRpND2uVyDekor9ubS5hRZhMBSdATD0w4emWnGDCxuSSPqMBwlsQCdANyCHgzWdIx00ZaRNHHfr
        run: |
          set -x  # Enable shell debug mode
          echo "ğŸ—ï¸ Building ${{ matrix.service }} with Turbo..."
          echo "ğŸ“¡ Turborepo Remote Cache: ${TURBO_API}"
          echo "ğŸ‘¥ Team: ${TURBO_TEAM}"
          echo "ğŸŒ Backend URL (PROD): ${BACKEND_SERVICE_URL_PROD}"
          echo "ğŸŒ Backend URL (DEV): ${BACKEND_SERVICE_URL_DEV}"
          echo "Current directory: $(pwd)"
          echo "Available disk space:"
          df -h

          if [[ "${{ matrix.service }}" == "admin" ]]; then
            FILTER="@jiffoo/admin"
          elif [[ "${{ matrix.service }}" == "docs-internal" || "${{ matrix.service }}" == "docs-public" ]]; then
            FILTER="${{ matrix.service }}"
          else
            FILTER="${{ matrix.service }}"
          fi

          echo "ğŸ“¦ Building with filter: ${FILTER}"
          echo "ğŸ” Checking for remote cache..."
          echo "Service directory: apps/${{ matrix.service }}"

          # Check if service directory exists
          if [ ! -d "apps/${{ matrix.service }}" ]; then
            echo "âŒ ERROR: Service directory apps/${{ matrix.service }} does not exist!"
            ls -la apps/
            exit 1
          fi

          # Run turbo build with remote cache and verbose output
          echo "Running: pnpm turbo run build --filter=${FILTER} --verbosity=2"
          pnpm turbo run build \
            --filter=${FILTER} \
            --token="${TURBO_TOKEN}" \
            --team="${TURBO_TEAM}" \
            --api="${TURBO_API}" \
            --verbosity=2 \
            --output-logs=full

          echo "âœ… Turbo build completed"
          echo "ğŸ’¾ Cache artifacts uploaded to remote cache server"

          # Check build output
          echo "Checking build output for ${{ matrix.service }}:"
          if [ -d "apps/${{ matrix.service }}/.next" ]; then
            echo "âœ… .next directory exists"
            ls -la "apps/${{ matrix.service }}/.next/" | head -20
          elif [ -d "apps/${{ matrix.service }}/dist" ]; then
            echo "âœ… dist directory exists"
            ls -la "apps/${{ matrix.service }}/dist/" | head -20
          else
            echo "âš ï¸ No build output directory found"
            ls -la "apps/${{ matrix.service }}/"
          fi

      - name: ğŸ—ï¸ Build Docker image
        id: build
        run: |
          set -x  # Enable shell debug mode

          # All services are now in apps/ directory
          DOCKERFILE_PATH="apps/${{ matrix.service }}/Dockerfile"

          IMAGE_BASE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ matrix.service }}"
          IMAGE_TAG="${IMAGE_BASE}:${{ steps.tags.outputs.tag }}"

          echo "ğŸ—ï¸ Building ${{ matrix.service }}..."
          echo "  ğŸ“ Dockerfile: ${DOCKERFILE_PATH}"
          echo "  ğŸ·ï¸ Image tag: ${IMAGE_TAG}"
          echo "  ğŸ“‚ Build context: $(pwd)"
          echo "  ğŸ’¾ Available disk space:"
          df -h

          # Check if Dockerfile exists
          if [ ! -f "${DOCKERFILE_PATH}" ]; then
            echo "âŒ ERROR: Dockerfile not found at ${DOCKERFILE_PATH}"
            ls -la "apps/${{ matrix.service }}/"
            exit 1
          fi

          echo "ğŸ“„ Dockerfile content (first 50 lines):"
          head -50 "${DOCKERFILE_PATH}"

          if [[ "${{ matrix.service }}" == "admin" || "${{ matrix.service }}" == "frontend" ]]; then
            export ESLINT_NO_DEV_ERRORS=true
            export NEXT_TELEMETRY_DISABLED=1
          fi

          echo "ğŸ³ Starting Docker build with detailed output..."
          echo "Build arguments:"
          echo "  - BUILDKIT_INLINE_CACHE=1"
          echo "  - ESLINT_NO_DEV_ERRORS=${ESLINT_NO_DEV_ERRORS:-false}"
          echo "  - NEXT_TELEMETRY_DISABLED=${NEXT_TELEMETRY_DISABLED:-0}"
          echo "  - HTTP_PROXY=http://192.168.0.106:7890"
          echo "  - HTTPS_PROXY=http://192.168.0.106:7890"

          # Build with detailed output
          time docker build \
            --file "${DOCKERFILE_PATH}" \
            --tag "${IMAGE_TAG}" \
            --build-arg BUILDKIT_INLINE_CACHE=1 \
            --build-arg ESLINT_NO_DEV_ERRORS=${ESLINT_NO_DEV_ERRORS:-false} \
            --build-arg NEXT_TELEMETRY_DISABLED=${NEXT_TELEMETRY_DISABLED:-0} \
            --build-arg HTTP_PROXY=http://192.168.0.106:7890 \
            --build-arg HTTPS_PROXY=http://192.168.0.106:7890 \
            --build-arg NO_PROXY=localhost,127.0.0.1,192.168.0.0/16,10.0.0.0/8 \
            --progress=plain \
            --no-cache \
            . 2>&1 | tee docker-build-${{ matrix.service }}.log

          BUILD_EXIT_CODE=${PIPESTATUS[0]}

          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            echo "âŒ Docker build failed with exit code: $BUILD_EXIT_CODE"
            echo "Last 100 lines of build log:"
            tail -100 docker-build-${{ matrix.service }}.log
            exit $BUILD_EXIT_CODE
          fi

          echo "âœ… Build completed successfully"
          echo "ğŸ“Š Image size:"
          docker images "${IMAGE_TAG}" --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"

      - name: ğŸš€ Push Docker image
        run: |
          IMAGE_BASE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ matrix.service }}"
          IMAGE_TAG="${IMAGE_BASE}:${{ steps.tags.outputs.tag }}"

          echo "ğŸš€ Pushing ${IMAGE_TAG}..."
          time docker push "${IMAGE_TAG}"

          docker tag "${IMAGE_TAG}" "${IMAGE_BASE}:latest"
          docker push "${IMAGE_BASE}:latest"

          echo "âœ… Successfully pushed"

      - name: ğŸ“¤ Upload build logs on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-${{ matrix.service }}
          path: |
            docker-build-${{ matrix.service }}.log
            apps/${{ matrix.service }}/.next/build-manifest.json
            apps/${{ matrix.service }}/.next/trace
          retention-days: 7
          if-no-files-found: ignore

      - name: ğŸ§¹ Post-build cleanup
        if: always()
        run: |
          echo "ğŸ§¹ Cleaning up..."
          docker builder prune -f --filter until=6h || true
          docker container prune -f || true
          rm -rf apps/${{ matrix.service }}/node_modules || true
          rm -rf apps/${{ matrix.service }}/.next || true
          echo "âœ… Cleanup completed"

  # ğŸ” Quality Gatesï¼ˆå¹¶è¡Œè¿è¡Œï¼Œä¸é˜»å¡æ„å»ºï¼‰
  quality-gates:
    name: ğŸ” Quality Gates
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: ğŸŒ Configure npm registry
        run: |
          npm config set registry https://registry.npmmirror.com
      
      - uses: pnpm/action-setup@v4
      
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
      
      - run: pnpm install --frozen-lockfile --prefer-offline
      
      - name: ğŸ” Lint
        run: pnpm lint || echo "âš ï¸ Lint skipped"
      
      - name: ğŸ§ª Test
        run: pnpm test || echo "âš ï¸ Test skipped"

  # ğŸ”’ Security Scanï¼ˆå¹¶è¡Œè¿è¡Œï¼‰
  security-scan:
    name: ğŸ”’ Security Scan
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: ğŸ” Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
        continue-on-error: true

      - name: ğŸ“Š Security Summary
        run: |
          echo "## ğŸ”’ Security Scan" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Vulnerability scan completed" >> $GITHUB_STEP_SUMMARY

  # ğŸ“¦ Generate Build Artifactsï¼ˆç­‰å¾…æ„å»ºå®Œæˆï¼‰
  generate-artifacts:
    name: ğŸ“¦ Generate Build Artifacts
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: ï¿½ï¿½ Generate build manifest
        run: |
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            VERSION="${GITHUB_REF#refs/tags/}"
          else
            VERSION="main-${SHORT_SHA}"
          fi
          
          cat > build-manifest.json << EOF
          {
            "version": "${VERSION}",
            "commit": "${{ github.sha }}",
            "ref": "${{ github.ref }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "services": ["backend","frontend","admin","super-admin","agent-portal","white-label","distribution-plugin","docs-internal","docs-public"]
          }
          EOF
          cat build-manifest.json

      - uses: actions/upload-artifact@v4
        with:
          name: build-manifest-${{ github.sha }}
          path: build-manifest.json
          retention-days: 30

  # ğŸš€ éƒ¨ç½²åˆ°æµ‹è¯•ç¯å¢ƒ
  deploy:
    name: ğŸš€ Deploy to Qujing (${{ needs.prepare.outputs.environment }})
    needs: [prepare, build-and-push]
    # Continue deployment even if some builds failed (e.g., agent-portal)
    # This allows other services to be deployed while we fix the failing service
    if: always() && needs.prepare.result == 'success'
    runs-on: jiffoo-mall-core-runners
    timeout-minutes: 30
    environment:
      name: ${{ needs.prepare.outputs.environment }}
    steps:
      - name: ğŸ“¥ Checkout
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup kubectl and helm
        run: |
          echo "ğŸ”§ Setting up kubectl and helm..."
          kubectl version --client
          helm version

          # Configure kubectl to use K8s API server directly (not in-cluster)
          # This works around network connectivity issues with kubernetes.default.svc
          mkdir -p ~/.kube
          cat > ~/.kube/config <<EOF
          apiVersion: v1
          kind: Config
          clusters:
          - cluster:
              certificate-authority: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
              server: https://192.168.0.100:6443
            name: qujing
          contexts:
          - context:
              cluster: qujing
              namespace: ${{ needs.prepare.outputs.namespace }}
              user: runner
            name: qujing
          current-context: qujing
          users:
          - name: runner
            user:
              tokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token
          EOF

          kubectl cluster-info
          echo "âœ… kubectl and helm configured"

      - name: ğŸ“¦ Create Namespace
        run: |
          echo "ğŸ“¦ Creating namespace ${{ needs.prepare.outputs.namespace }}..."
          kubectl create namespace ${{ needs.prepare.outputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -
          echo "âœ… Namespace ready"

      - name: ğŸš€ Deploy with Helm
        run: |
          echo "ğŸš€ Deploying to Qujing K8s..."
          echo "  ğŸ“¦ Environment: ${{ needs.prepare.outputs.environment }}"
          echo "  ğŸ“¦ Namespace: ${{ needs.prepare.outputs.namespace }}"
          echo "  ğŸ·ï¸ Version: ${{ needs.prepare.outputs.version }}"

          # Clean up any stuck Helm release secrets
          echo ""
          echo "ğŸ” Checking for stuck Helm release secrets..."

          # Find all Helm secrets for this release with pending status
          STUCK_SECRETS=$(kubectl get secrets -n ${{ needs.prepare.outputs.namespace }} \
            -l owner=helm,name=jiffoo-mall-core \
            -o json 2>/dev/null | \
            jq -r '.items[] | select(.metadata.labels.status | test("pending")) | .metadata.name' || echo "")

          if [ -n "$STUCK_SECRETS" ]; then
            echo "âš ï¸ Found stuck Helm release secrets:"
            echo "$STUCK_SECRETS"
            echo ""
            echo "ğŸ§¹ Cleaning up stuck secrets..."

            for secret in $STUCK_SECRETS; do
              echo "  Deleting: $secret"
              kubectl delete secret $secret -n ${{ needs.prepare.outputs.namespace }} || true
            done

            echo "âœ… Stuck secrets cleaned up"
            sleep 2
          else
            echo "âœ… No stuck Helm secrets found"
          fi

          # Also check for any Helm release in pending state
          echo ""
          echo "ğŸ” Checking Helm release status..."
          RELEASE_STATUS=$(helm list -n ${{ needs.prepare.outputs.namespace }} -o json 2>/dev/null | \
            jq -r '.[] | select(.name=="jiffoo-mall-core") | .status' || echo "")

          if [ -n "$RELEASE_STATUS" ]; then
            echo "  Current release status: $RELEASE_STATUS"

            if [[ "$RELEASE_STATUS" == pending-* ]]; then
              echo "âš ï¸ Release is in pending state, forcing cleanup..."
              # Delete ALL Helm secrets for this release to force a clean state
              kubectl delete secrets -n ${{ needs.prepare.outputs.namespace }} \
                -l owner=helm,name=jiffoo-mall-core || true
              sleep 2
            fi
          else
            echo "  No existing release found"
          fi

          # Clean up existing Services if Helm release is in failed state
          # This is necessary because Service NodePorts are immutable and --force doesn't delete Services
          echo ""
          echo "ğŸ§¹ Checking for failed Helm release..."
          RELEASE_STATUS=$(helm status jiffoo-mall-core -n ${{ needs.prepare.outputs.namespace }} -o json 2>/dev/null | jq -r '.info.status' || echo "not-found")

          if [ "$RELEASE_STATUS" = "failed" ]; then
            echo "âš ï¸  Found failed release, cleaning up Services to allow recreation..."
            kubectl delete svc -n ${{ needs.prepare.outputs.namespace }} \
              -l app.kubernetes.io/instance=jiffoo-mall-core \
              --ignore-not-found=true
            echo "âœ… Services cleaned up"
            sleep 2
          else
            echo "âœ… Release status: $RELEASE_STATUS (no cleanup needed)"
          fi

          # Deploy with Helm (without --wait to avoid timeout)
          # Use --force to handle failed releases and recreate resources if needed
          echo ""
          echo "ğŸš€ Starting Helm deployment..."
          helm upgrade --install jiffoo-mall-core \
            ./deploy/helm \
            --namespace ${{ needs.prepare.outputs.namespace }} \
            --values ./deploy/helm/values-${{ needs.prepare.outputs.environment }}.yaml \
            --set global.image.tag=${{ needs.prepare.outputs.version }} \
            --set global.image.registry=${{ env.REGISTRY }} \
            --create-namespace \
            --force

          echo "âœ… Helm deployment initiated"
          echo ""

          # Wait for pods to be created (max 2 minutes)
          echo "â³ Waiting for pods to be created..."
          for i in {1..24}; do
            POD_COUNT=$(kubectl get pods -n ${{ needs.prepare.outputs.namespace }} --no-headers 2>/dev/null | wc -l || echo "0")
            if [ "$POD_COUNT" -gt 0 ]; then
              echo "âœ… Found $POD_COUNT pods"
              break
            fi
            echo "  Waiting... ($i/24)"
            sleep 5
          done

          echo ""
          echo "=== Current Pods Status ==="
          kubectl get pods -n ${{ needs.prepare.outputs.namespace }} -o wide

          echo ""
          echo "=== Helm Release Status ==="
          helm list -n ${{ needs.prepare.outputs.namespace }}

          echo ""
          echo "=== Recent Events ==="
          kubectl get events -n ${{ needs.prepare.outputs.namespace }} --sort-by='.lastTimestamp' | tail -30

          echo ""
          echo "=== Checking for Failed Pods ==="
          FAILED_PODS=$(kubectl get pods -n ${{ needs.prepare.outputs.namespace }} --field-selector=status.phase!=Running --no-headers -o custom-columns=":metadata.name" 2>/dev/null || true)
          if [ -n "$FAILED_PODS" ]; then
            echo "âš ï¸ Found pods not in Running state:"
            for pod in $FAILED_PODS; do
              echo ""
              echo "--- Pod: $pod ---"
              kubectl describe pod $pod -n ${{ needs.prepare.outputs.namespace }} | grep -A 10 "Events:" || true
              echo ""
              echo "--- Logs for $pod ---"
              kubectl logs $pod -n ${{ needs.prepare.outputs.namespace }} --tail=50 || true
            done
          else
            echo "âœ… All pods are in Running state"
          fi

          echo ""
          echo "ğŸ‰ Deployment process completed!"
          echo "ğŸ“ Note: Pods may still be starting up. Check status with: kubectl get pods -n ${{ needs.prepare.outputs.namespace }}"

      - name: ğŸ“Š Deployment Summary
        run: |
          echo "## ğŸ‰ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment**: ${{ needs.prepare.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Namespace**: ${{ needs.prepare.outputs.namespace }}" >> $GITHUB_STEP_SUMMARY
          echo "**Version**: ${{ needs.prepare.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Cluster**: Qujing K8s" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ“¦ Deployed Services" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          kubectl get deployments -n ${{ needs.prepare.outputs.namespace }} -o custom-columns=NAME:.metadata.name,READY:.status.readyReplicas,AVAILABLE:.status.availableReplicas,IMAGE:.spec.template.spec.containers[0].image >> $GITHUB_STEP_SUMMARY || echo "âš ï¸ Could not list deployments" >> $GITHUB_STEP_SUMMARY

  # ğŸ§¹ Final System Cleanupï¼ˆç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆï¼‰
  final-cleanup:
    name: ğŸ§¹ Final System Cleanup
    needs: [build-and-push, quality-gates, security-scan, generate-artifacts, deploy]
    if: always()
    runs-on: jiffoo-mall-core-runners
    steps:
      - name: ğŸ§¹ Cleanup Docker resources
        run: |
          echo "ğŸ§¹ Cleaning up Docker resources..."
          docker system prune -af --filter until=24h || true
          docker volume prune -f || true
          echo "âœ… Docker cleanup completed"

      - name: ğŸ“Š Cleanup Summary
        run: |
          echo "## ğŸ§¹ Final Cleanup" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Docker resources cleaned" >> $GITHUB_STEP_SUMMARY
          echo "ğŸ‰ CI/CD pipeline completed!" >> $GITHUB_STEP_SUMMARY

  # ğŸ“¢ Send Feishu Notification
  notify-feishu:
    name: ğŸ“¢ Send Feishu Notification
    needs: [prepare, build-and-push, deploy]
    if: always()
    runs-on: jiffoo-mall-core-runners
    steps:
      - name: ğŸ“¢ Send deployment notification to Feishu
        env:
          FEISHU_WEBHOOK: ${{ secrets.FEISHU_WEBHOOK_JIFFOO }}
        run: |
          # Skip if webhook is not configured
          if [ -z "$FEISHU_WEBHOOK" ]; then
            echo "â­ï¸ Skipping Feishu notification (webhook not configured)"
            exit 0
          fi
          # Determine overall status
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            STATUS="âœ… éƒ¨ç½²æˆåŠŸ"
            COLOR="green"
          elif [ "${{ needs.deploy.result }}" == "failure" ]; then
            STATUS="âŒ éƒ¨ç½²å¤±è´¥"
            COLOR="red"
          elif [ "${{ needs.deploy.result }}" == "skipped" ]; then
            STATUS="â­ï¸ éƒ¨ç½²è·³è¿‡"
            COLOR="orange"
          else
            STATUS="âš ï¸ éƒ¨ç½²çŠ¶æ€æœªçŸ¥"
            COLOR="grey"
          fi

          # Build service status list
          SERVICES="backend frontend admin super-admin agent-portal white-label distribution-plugin docs-internal docs-public"
          SERVICE_STATUS=""
          for service in $SERVICES; do
            SERVICE_STATUS="${SERVICE_STATUS}**${service}**: âœ… æˆåŠŸ\n"
          done

          # Send to Feishu
          curl -X POST "$FEISHU_WEBHOOK" \
            -H "Content-Type: application/json" \
            -d "{
              \"msg_type\": \"interactive\",
              \"card\": {
                \"header\": {
                  \"title\": {
                    \"tag\": \"plain_text\",
                    \"content\": \"ğŸš€ Jiffoo Mall éƒ¨ç½²é€šçŸ¥\"
                  },
                  \"template\": \"${COLOR}\"
                },
                \"elements\": [
                  {
                    \"tag\": \"div\",
                    \"text\": {
                      \"tag\": \"lark_md\",
                      \"content\": \"**çŠ¶æ€**: ${STATUS}\n**ç¯å¢ƒ**: ${{ needs.prepare.outputs.environment }}\n**ç‰ˆæœ¬**: ${{ needs.prepare.outputs.version }}\n**åˆ†æ”¯**: ${{ github.ref_name }}\n**æäº¤**: ${{ github.sha }}\n**è§¦å‘è€…**: ${{ github.actor }}\"
                    }
                  },
                  {
                    \"tag\": \"hr\"
                  },
                  {
                    \"tag\": \"div\",
                    \"text\": {
                      \"tag\": \"lark_md\",
                      \"content\": \"**æœåŠ¡çŠ¶æ€**:\n${SERVICE_STATUS}\"
                    }
                  },
                  {
                    \"tag\": \"hr\"
                  },
                  {
                    \"tag\": \"div\",
                    \"text\": {
                      \"tag\": \"lark_md\",
                      \"content\": \"**ğŸŒ æœåŠ¡è®¿é—®åœ°å€** (devç¯å¢ƒ - NodePort):\"
                    }
                  },
                  {
                    \"tag\": \"action\",
                    \"actions\": [
                      {
                        \"tag\": \"button\",
                        \"text\": {
                          \"tag\": \"plain_text\",
                          \"content\": \"ğŸ¨ Frontend\"
                        },
                        \"url\": \"http://jiffoo.chfastpay.com:30001\"
                      },
                      {
                        \"tag\": \"button\",
                        \"text\": {
                          \"tag\": \"plain_text\",
                          \"content\": \"ğŸ‘¨â€ğŸ’¼ Admin\"
                        },
                        \"url\": \"http://jiffoo.chfastpay.com:30003\"
                      },
                      {
                        \"tag\": \"button\",
                        \"text\": {
                          \"tag\": \"plain_text\",
                          \"content\": \"ğŸ¦¸ Super Admin\"
                        },
                        \"url\": \"http://jiffoo.chfastpay.com:30004\"
                      }
                    ]
                  },
                  {
                    \"tag\": \"action\",
                    \"actions\": [
                      {
                        \"tag\": \"button\",
                        \"text\": {
                          \"tag\": \"plain_text\",
                          \"content\": \"ğŸ¤ Agent Portal\"
                        },
                        \"url\": \"http://jiffoo.chfastpay.com:30005\"
                      },
                      {
                        \"tag\": \"button\",
                        \"text\": {
                          \"tag\": \"plain_text\",
                          \"content\": \"ğŸ·ï¸ White Label\"
                        },
                        \"url\": \"http://jiffoo.chfastpay.com:30006\"
                      },
                      {
                        \"tag\": \"button\",
                        \"text\": {
                          \"tag\": \"plain_text\",
                          \"content\": \"ğŸ”Œ Distribution\"
                        },
                        \"url\": \"http://jiffoo.chfastpay.com:30007\"
                      }
                    ]
                  },
                  {
                    \"tag\": \"action\",
                    \"actions\": [
                      {
                        \"tag\": \"button\",
                        \"text\": {
                          \"tag\": \"plain_text\",
                          \"content\": \"ğŸ“š Docs Internal\"
                        },
                        \"url\": \"http://jiffoo.chfastpay.com:30008\"
                      },
                      {
                        \"tag\": \"button\",
                        \"text\": {
                          \"tag\": \"plain_text\",
                          \"content\": \"ğŸ“– Docs Public\"
                        },
                        \"url\": \"http://jiffoo.chfastpay.com:30009\"
                      },
                      {
                        \"tag\": \"button\",
                        \"text\": {
                          \"tag\": \"plain_text\",
                          \"content\": \"ğŸ”§ Backend API\"
                        },
                        \"url\": \"http://jiffoo.chfastpay.com:30002\"
                      }
                    ]
                  },
                  {
                    \"tag\": \"hr\"
                  },
                  {
                    \"tag\": \"action\",
                    \"actions\": [
                      {
                        \"tag\": \"button\",
                        \"text\": {
                          \"tag\": \"plain_text\",
                          \"content\": \"ğŸ“‹ æŸ¥çœ‹éƒ¨ç½²è¯¦æƒ…\"
                        },
                        \"type\": \"primary\",
                        \"url\": \"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\"
                      }
                    ]
                  }
                ]
              }
            }"

          echo "âœ… Notification sent to Feishu"
