# 内部插件系统开发指南

> 本文档是 Jiffoo 内部插件系统的权威开发规范，适用于所有业务插件和 UI 主题插件。  
> 目标是形成一套可以复刻、可演进的统一开发体系。

---

## 1. 文档定位与适用范围

- 适用对象：
  - 编写或维护插件的后端 / 前端工程师。
  - 需要理解插件商业化模型的产品 / 运营同学。
- 适用插件类型：
  - 业务逻辑插件（如：Stripe 支付、Resend 邮件、Google OAuth、Affiliate 分销等）。
  - UI 主题插件（商城前端主题）。
- 默认前端暴露面：
  - 超级管理员（Super Admin）：管理全局插件仓库和商业信息。
  - 管理员（Admin）：管理租户维度的插件安装、配置和订阅。
  - 商城前端（Mall）：可选，视插件功能决定是否需要面向终端用户暴露能力。

---

## 2. 插件分类与角色

插件在系统中的角色分为三类：

1. **基础设施插件（Infrastructure Plugins）**
   - 典型实现：
     - `apps/backend/src/plugins/tenant-context.ts`
     - `apps/backend/src/plugins/commercial-support.ts`
     - `apps/backend/src/plugins/plugin-registry.ts`
     - `apps/backend/src/plugins/plugin-installer.ts`
   - 提供平台级能力（多租户上下文、商业化能力、插件注册表、安装生命周期等）。
   - 只由核心团队维护，不对外开放扩展。

2. **业务插件（Business Plugins）**
   - 典型实现：
    - `apps/backend/src/plugins/stripe.ts`
    - `apps/backend/src/plugins/resend.ts`
    - `apps/backend/src/plugins/google.ts`
     - `apps/backend/src/plugins/affiliate.ts`
   - 提供具体业务能力（支付、邮件、登录、分销等）。
   - 多数是商业化插件，使用订阅制或买断制。

3. **UI 主题插件（Theme Plugins）**
   - 控制商城前端的 UI 和布局，通过主题系统暴露组件。  
   - 安装后会更新 `Tenant.theme` 配置，并通过 `MallContextProvider` + `ThemeProvider` + `ThemedLayout` 生效。

> 新插件默认属于 “业务插件” 或 “主题插件”。基础设施插件只在架构演进时由核心团队扩展。

---

## 3. 系统架构总览

### 3.1 后端整体结构

```text
Fastify Application
├── Infrastructure Plugins
│   ├── tenant-context        // 提供 request.tenant，多租户隔离
│   ├── commercial-support    // 许可证 / 订阅 / 用量 / 买断制
│   ├── plugin-registry       // 插件查询、详情、分类、搜索
│   └── plugin-installer      // 安装 / 卸载 / 启用 / 禁用 / 订阅绑定
├── Business Plugins          // Stripe / Resend / Google OAuth / Affiliate 等
│   └── /api/plugins/<slug>/api/*
└── Theme System
    ├── Theme plugins (category=theme)
    └── MallContextProvider + ThemeProvider + ThemedLayout
```

### 3.2 路由前缀约定

- 所有业务插件的 HTTP API 必须挂载在：
  - `/api/plugins/<plugin-slug>/api/*`
- Fastify 注册示例（`apps/backend/src/server.ts` 中）：

```ts
const stripePayment = await import('./plugins/stripe');
await fastify.register(stripePayment.default, {
  prefix: '/api/plugins/stripe/api',
  secretKey: env.STRIPE_SECRET_KEY,
  webhookSecret: env.STRIPE_WEBHOOK_SECRET,
});
```

> 业务模块（如订单服务）通过该 URL 访问插件，而不是直接 import 插件内部函数。

### 3.3 前端三种暴露面

- **Super Admin**：管理全局插件（`/api/super-admin/plugins/...` 或专用 API）。
- **Admin**：管理当前租户插件（`/admin/plugins/...`）。
- **Mall**：终端用户使用插件能力（例如 `/api/plugins/stripe/api/verify-session`）。

每个插件在设计时，必须先确定：

- 是否需要 Super Admin 管理面？
- 对 Admin 暴露哪些管理能力（安装 / 配置 / 订阅 / 用量）？
- 是否对 Mall 暴露使用能力（支付、登录、UI 等）？

---

## 4. 数据模型与商业化约定（高层）

> 详细字段以 `apps/backend/prisma/schema.prisma` 为准，此处只列出关键关系和约定。

### 4.1 核心实体

- `Plugin`
  - 标识：`id`, `slug`, `name`, `category`, `tags`, `version`, `status`, `iconUrl` 等。
  - 商业信息不再使用 `pricing` 字段，而是通过 `SubscriptionPlan` / `PluginLicense` 推导。

- `PluginInstallation`
  - `tenantId`, `pluginId`, `status`, `enabled`。
  - `configData`：JSON，存储租户级插件配置。
  - 每个租户对每个插件最多一条安装记录（唯一约束）。

- `PluginUsage`
  - 按 `(tenantId, pluginSlug, metricName, period)` 维度计量。
  - 示例指标：`api_calls`, `transactions`, `refunds`, `emails_sent`, `login_attempts` 等。

- `Payment`
  - `orderId`, `tenantId`, `pluginId`, `paymentMethod`, `sessionId`, `sessionUrl`, `expiresAt`, `attemptNumber` 等。
  - 记录哪个插件处理了这次支付，支持会话复用和重试。

### 4.2 订阅制模型

- `SubscriptionPlan`
  - 归属：`pluginId`。
  - 字段：`planId`, `name`, `features`（JSON 字符串）, `amount`, `currency`, `billingCycle`, `trialDays`, `isActive`。
  - `features` 中的 key 将在 `checkPluginLicense` / `checkSubscriptionAccess` 中使用（如 `basic_payments`, `refunds`, `installments`）。

- `Subscription`
  - 归属：`tenantId + pluginId`。
  - 字段：`planId`, `status`, `currentPeriodStart`, `currentPeriodEnd`, `stripeSubscriptionId`, `metadata` 等。

- 辅助实体：
  - `TenantCustomPricing`：租户级 custom 价格和功能包（覆盖标准 plan）。
  - `TenantFeatureOverride`：租户级功能开关（单个 feature 的特例开/关）。

### 4.3 买断制模型

- `PluginLicense`
  - 归属：`tenantId + pluginId`。
  - 字段：`status`, `purchaseDate`, `activatedAt`, `amount`, `currency` 等。
  - 买断制插件（如 Affiliate）通过 `checkAffiliateLicense` 检查许可证状态。

### 4.4 商业化装饰器（由 commercial-support 插件提供）

业务插件需要统一复用以下装饰器，而不是自己实现商业化逻辑：

- `checkPluginLicense(tenantId, pluginSlug, feature?)`
- `checkAffiliateLicense(tenantId)`
- `checkSubscriptionAccess(tenantId, pluginSlug, feature?)`
- `resetPluginUsageForPeriod(tenantId, pluginSlug, period, metrics?)`
- 以及订阅管理相关装饰器（`createSubscription`, `updateSubscription`, `cancelSubscription` 等）。

---

## 5. 后端插件开发规范

### 5.1 通用规则

1. **插件标识**
   - `slug` 必须全局唯一，使用简单英文单词，如：`stripe`, `resend`, `google`, `affiliate`。
   - `category` 用于在市场中分组：`payment`, `email`, `integration`, `theme`, `analytics`, `marketing` 等。
   - `tags` 建议为 JSON 数组字符串（例如：`["themeSlug:default","official"]`）。

2. **路由前缀**
   - 所有业务插件路由必须挂载在：`/api/plugins/<slug>/api` 下。
   - 插件内部定义的路径不再重复 `/api/plugins/...` 前缀，只写 `/health`, `/create-checkout-session` 等相对路径。

3. **多租户约定**
   - 必须依赖 `tenant-context` 插件提供的 `request.tenant`。
   - 禁止在插件中使用全局变量保存租户相关状态。

4. **错误与状态码约定（建议）**
   - 401：缺少租户上下文或认证信息。
   - 402：需要订阅（如 `checkSubscriptionAccess` 未通过）。
   - 403：许可证 / 功能权限不足（如 `checkPluginLicense` 未通过）。
   - 429：用量超限（`checkUsageLimit` 未通过）。
   - 5xx：插件内部错误或下游服务异常。

### 5.2 业务插件开发流程（订阅制 / 买断制通用）

1. **在 Plugin 表中注册插件**
   - 新增一条 `Plugin` 记录，设置：`slug`, `name`, `category`, `tags`, `iconUrl`, `version`, `status` 等。

2. **配置商业模式**
   - 订阅制：为该插件在 `SubscriptionPlan` 表中配置一组计划（free/basic/pro 等），填好 `features`。
   - 买断制：由购买流程或手工脚本在 `PluginLicense` 中写入记录。

3. **实现 Fastify 插件模块**
   - 文件建议放在：`apps/backend/src/plugins/<plugin-slug>.ts`。
   - 使用 `FastifyPluginAsync<Options>` 形式导出默认插件函数。
   - 一般不再用 `fastify-plugin` 包裹（除非该插件需要做全局装饰器，而不是按 prefix 提供路由）。

4. **在 server.ts 中注册插件**
   - 使用动态 import + `fastify.register(plugin.default, { prefix, ...options })` 注册。

5. **集成商业化装饰器**
   - 在路由的 `preHandler` 中调用：
     - `checkPluginLicense`（检查插件是否安装、功能是否包含）。
     - `checkSubscriptionAccess`（订阅状态 / 宽限期）。
     - `checkUsageLimit` + `recordPluginUsage`（用量控制和记录）。

6. **与核心业务模块集成**
   - 例如订单模块通过 `fastify.inject` 调用 `/api/plugins/<slug>/api/create-checkout-session`，而不是直接依赖插件内部函数。

### 5.3 主题插件开发规范

1. **Plugin 标记**
   - `category = 'theme'`。
   - `tags` 中包含 `themeSlug:<slug>`，例如：`["themeSlug:default","official"]`。

2. **安装时特殊处理**
   - `AdminPluginService.installPlugin` 会：
     - 禁用当前租户其他 `category = 'theme'` 的插件。
     - 更新 `Tenant.theme = { slug, config, version, pluginSlug }`。
     - 清理商城上下文缓存（确保新主题生效）。

3. **与前端主题系统集成**
   - `MallContextProvider` 从后端拉取 `context.theme.slug` 和 `config`。
   - `ThemeProvider` 根据 `slug` 加载对应主题包。
   - `ThemedLayout` 从主题包中读取组件（`Header`, `Footer`, `OrderSuccessPage`, `NotFound` 等）进行渲染。

---

## 6. 前端集成规范：Super Admin / Admin / Mall

> 本节从更高视角约定“插件要在三种前端面暴露什么能力”，具体组件实现由各插件自行设计。

### 6.1 Super Admin 面（平台运营）

- 目标：管理全局插件列表、商业计划和默认配置。
- 插件侧要求：
  - 能被 Super Admin 查看、搜索和管理（一般通过 `/api/super-admin/plugins/...` 或专用 API）。
  - 支持配置 / 修改 `SubscriptionPlan`、默认状态、上架 / 下架。

### 6.2 Admin 面（租户管理员）

- 目标：让租户管理员在后台管理插件：安装、启用、配置、订阅、用量。
- 插件侧要求：
  - 复用 `plugin-registry` + `plugin-installer` 提供的能力，通过 Admin 路由暴露：
    - `/admin/plugins/marketplace`
    - `/admin/plugins/installed`
    - `/admin/plugins/:slug/install`
    - `/admin/plugins/:slug/config`
  - 对需要运营界面的插件（如 Resend / Stripe / Google OAuth / Affiliate）提供 Admin 页面：
    - 建议路径：`apps/admin/app/plugins/installed/<plugin-slug>/page.tsx`。
    - 通过 `apps/admin/lib/api.ts` 中的 `pluginsApi` 或 `<slug>PluginApi` 调用后端。

### 6.3 Mall 面（可选，面向终端用户）

- 目标：在商城中向终端用户提供功能（支付、登录、前端 UI、营销组件等）。
- 插件侧要求：
  - 所有面向 Mall 的 API 必须通过 `/api/plugins/<slug>/api` 暴露。
  - 必须使用 `tenant-context` 提供的 `request.tenant` 进行多租户隔离。
  - 流程型功能（如支付 / 登录）在对应页面或 Hook 中调用插件 API，并做好失败兜底。
  - UI 型功能（如主题）通过主题系统或组件 props 接入。

> 每个插件在设计时，必须先决定自己是否需要暴露：Super Admin 面、Admin 面、Mall 面，然后按本节规范组合即可。

---

## 7. 新插件开发 Checklist

> 这一节是整份文档的“压缩版”，实现一个新插件时至少要逐条确认。

1. **确定插件类型与作用范围**
   - 类型：业务插件 / 主题插件。
   - 商业模式：订阅制 / 买断制 / 免费。
   - 前端面：是否需要 Super Admin / Admin / Mall。

2. **注册插件元数据**
   - 在 `Plugin` 表中新增记录，设置 `slug`, `name`, `category`, `tags`, `iconUrl`, `status` 等。
   - 对于主题插件，确保 `category = 'theme'` 且 `tags` 含 `themeSlug:<slug>`。

3. **配置商业模型**
   - 订阅制：在 `SubscriptionPlan` 表中为该插件添加计划，写好 `features`。
   - 买断制：设计创建 `PluginLicense` 的流程（购买时或手工导入）。

4. **实现后端插件模块**
   - 在 `apps/backend/src/plugins/<slug>.ts` 中实现 `FastifyPluginAsync` 插件。
   - 在 `server.ts` 中通过 `fastify.register(plugin.default, { prefix: '/api/plugins/<slug>/api', ... })` 注册。
   - 在路由 `preHandler` 中调用 `checkPluginLicense` / `checkSubscriptionAccess` / `checkUsageLimit` + `recordPluginUsage`。

5. **集成到核心业务流程（如需要）**
   - 通过 `fastify.inject` 或内部服务调用插件 API，而不是直接 import 插件内部实现。

6. **实现前端管理与使用界面**
   - Super Admin 面（如需要）：接入全局插件管理 API。
   - Admin 面：在 Admin 应用中增加插件市场 / 安装 / 配置 / 订阅 / 用量界面。
   - Mall 面（如需要）：在商城前端页面或主题组件中调用插件的 Mall API。

7. **验证与上线**
   - 在测试环境验证：安装 / 升级 / 卸载、多租户隔离、限流和商业化行为。

---

## 8. Stripe 支付插件示例（参考实现）

> Stripe 支付插件是当前线上验证过的完整实现，可作为开发新业务插件的参考模板。

### 8.1 插件元数据与商业模型

1. **Plugin 记录**
   - `slug = 'stripe'`，`category = 'payment'`。
   - `tags` 中可包含如 `["official","payment","stripe"]`。

2. **订阅计划**
   - 在 `SubscriptionPlan` 表中为 `stripe` 配置多个计划：
     - 例如：`free`, `pro`, `enterprise`。
     - 每个计划在 `features` 字段中定义功能列表，如：
       - `basic_payments`（基础支付）
       - `refunds`（退款）
       - `installments`（分期）
       - `all_features`（全量功能）

3. **用量指标**
   - 在商业化插件中约定并使用以下指标：
     - `api_calls`：插件 API 调用次数。
     - `transactions`：成功交易次数。
     - `refunds`：退款次数。

### 8.2 后端插件实现（业务插件）

1. **插件文件**
   - 位置：`apps/backend/src/plugins/stripe-payment.ts`。
   - 结构：
     - 导出 `const stripePayment: FastifyPluginAsync<StripePaymentOptions>`。
     - 内部实现：
       - `getStripeConfig(tenantId)`：读取插件安装配置（平台秘钥 / BYOK 模式）。
       - `createStripeInstance(secretKey)`：为当前租户构造 Stripe 客户端。

2. **路由示例：创建支付会话**

```ts
fastify.post('/create-checkout-session', {
  preHandler: async (request: any, reply: any) => {
    // 1) 检查许可证（插件是否安装 + 是否包含 basic_payments 功能）
    const licenseCheck = await fastify.checkPluginLicense(
      request.tenant.id,
      'stripe',
      'basic_payments',
    );
    if (!licenseCheck.valid) {
      return reply.status(403).send({
        error: 'License required',
        reason: licenseCheck.reason,
        upgradeUrl: licenseCheck.upgradeUrl,
      });
    }

    // 2) 检查用量（API 调用次数）
    const apiCallCheck = await fastify.checkUsageLimit(
      request.tenant.id,
      'stripe',
      'api_calls',
    );
    if (!apiCallCheck.allowed) {
      return reply.status(429).send({
        error: 'API call limit exceeded',
        current: apiCallCheck.current,
        limit: apiCallCheck.limit,
        percentage: apiCallCheck.percentage,
        upgradeUrl: `/plugins/stripe/upgrade`,
      });
    }

    // 3) 检查用量（交易次数）
    const transactionCheck = await fastify.checkUsageLimit(
      request.tenant.id,
      'stripe',
      'transactions',
    );
    if (!transactionCheck.allowed) {
      return reply.status(429).send({
        error: 'Transaction limit exceeded',
        current: transactionCheck.current,
        limit: transactionCheck.limit,
        percentage: transactionCheck.percentage,
        upgradeUrl: `/plugins/stripe/upgrade`,
      });
    }

    // 4) 记录 API 调用次数（交易次数在支付成功时再记录）
    await fastify.recordPluginUsage(request.tenant.id, 'stripe', 'api_calls');
  },
}, async (request: any, reply: any) => {
  // 5) 创建 Stripe Checkout Session（简化示例，不展开细节）
  const stripeConfig = await getStripeConfig(request.tenant.id);
  const stripe = createStripeInstance(stripeConfig.secretKey);

  // 使用订单信息构造 line_items，创建 Session ...
  // 创建成功后，写入 Payment 记录（包含 pluginId / sessionId / sessionUrl / expiresAt 等）

  return {
    success: true,
    data: {
      sessionId: 'cs_test_xxx',
      url: 'https://checkout.stripe.com/pay/cs_test_xxx',
      expiresAt: new Date().toISOString(),
    },
  };
});
```

3. **路由示例：高级功能（退款 / 分期）**

- 退款：在 `preHandler` 中检查 `refunds` 功能，并对 `refunds` 指标计量。
- 分期：在 `preHandler` 中检查 `installments` 功能，并对 `installments` 指标计量。

通过这种模式，所有商业功能和用量控制都被统一收敛到 `commercial-support` 插件内部。

### 8.3 与订单服务集成（Mall 后端）

1. **订单支付重试**
   - 位置：`apps/backend/src/core/order/service.ts` 中的 `retryPayment` 方法。
   - 核心逻辑：
     - 验证订单状态和库存。
     - 判断是否可以复用已有 Stripe Session（根据 `Payment` 记录和 `expiresAt`）。
     - 如果需要新的 Session：
       - 根据 `paymentMethod` 选择调用的插件 URL：
         - `stripe` 固定路由：`/api/plugins/stripe/api/create-checkout-session`。
         - 其他支付插件：`/api/plugins/${paymentMethod}/api/create-checkout-session`。
       - 使用 `fastify.inject` 调用插件 API，并解析返回的 `sessionId` / `url` / `expiresAt`。

2. **多支付方式支持**
   - 订单服务永远只关心 “插件 slug + 标准接口约定”，不关心插件内部实现。
   - 新增支付插件时，只要实现相同的接口语义，即可被订单服务复用。

### 8.4 Admin 集成（租户配置 / 订阅管理）

1. **Admin API 封装**
   - 位置：`apps/admin/lib/api.ts` 中的 `stripePluginApi`。
   - 封装了以下典型操作：
     - 获取升级预览：`/plugins/stripe/api/plan/upgrade-preview`。
     - 创建升级 checkout：`/plugins/stripe/api/plan/upgrade`。
     - 降级：`/plugins/stripe/api/plan/downgrade`。
     - 查询当前计划：`/plugins/stripe/api/plan/current`。

2. **Admin UI 页面**
   - 建议参考 Resend 插件页面的结构：
     - 基本信息卡片（名称 / 描述 / 状态 / 版本）。
     - 插件配置表单（例如 BYOK 配置）。
     - 订阅与用量面板（当前计划、可用计划、用量进度条）。
     - 升级 / 降级 / 取消降级对话框。

### 8.5 Mall 集成（订单支付完成页）

1. **前端页面**
   - 位置：`apps/frontend/app/order-success/page.tsx`。
   - 核心逻辑：
     - 从 URL 中获取 `session_id`。
     - 调用：`/api/plugins/stripe/api/verify-session?session_id=...`。
     - 根据返回结果：
       - 设置订单号（真实或 fallback）。
       - 清空购物车。

2. **体验层与主题系统的关系**
   - 订单成功页本身使用当前主题提供的 `OrderSuccessPage` 组件进行渲染：
     - 插件只负责返回业务数据（订单号是否有效），不直接渲染 UI。

---

通过以上 Stripe 支付插件示例，新插件开发者可以按以下方式进行“复刻”：

- 保留商业化接入模式（check + usage + subscription）。
- 复用相同的插件 API 路径结构（`/api/plugins/<slug>/api/...`）。
- 在 Super Admin / Admin / Mall 侧按同样的方式封装 API 与 UI。

在此基础上，新的业务插件或主题插件可以快速接入到现有插件生态和商业化体系中。

---

## 9. 参考资料

- Fastify 官方插件文档：https://fastify.io/docs/latest/Reference/Plugins/
- Fastify 插件开发指南：https://fastify.io/docs/latest/Guides/Plugins-Guide/
- fastify-plugin 文档：https://github.com/fastify/fastify-plugin
- Stripe API 文档：https://stripe.com/docs/api
- Prisma Schema：`apps/backend/prisma/schema.prisma`
- Stripe 插件实现参考：`apps/backend/src/plugins/stripe.ts`
- 插件商业化实现参考：`apps/backend/src/plugins/commercial-support.ts`
- 插件注册与安装实现参考：
  - `apps/backend/src/plugins/plugin-registry.ts`
  - `apps/backend/src/plugins/plugin-installer.ts`
